<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python实现图片转字符串]]></title>
    <url>%2F2018%2F12%2F14%2Fpython%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页版微信定时自动给好友发消息]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%BE%AE%E4%BF%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[操作步骤： 1.登陆网页版微信 2.打开开发者工具（F12） 3.打开 console 控制台 4.粘贴一下代码到控制台并回车 实现原理： 1.遍历好友列表 2.修改输入框文本 3.点击发送 源代码： 循环发送（每隔3秒发送一次）： function show(){ $(&apos;.edit_area&apos;).html(&apos;需要发送的文字&apos;); $(&quot;.edit_area&quot;).trigger($.Event(&quot;keydown&quot;, { keyCode: 13,ctrlKey: true})); $(&apos;.btn_send&apos;).click(); } var sh; sh=setInterval(show,3000); clearInterval(sh); //这行用来停止发送 new Date().toLocaleString()， //回车，查看输出的信息； 定时发送（需注意日期格式）: setInterval(function(){ if(new Date().toLocaleString().indexOf(&apos;2015/8/31 下午4:02:00&apos;)===0) { $(&apos;.edit_area&apos;).html(&apos;需要发送的文字&apos;); $(&quot;.edit_area&quot;).trigger($.Event(&quot;keydown&quot;, { keyCode: 13,ctrlKey: true})); $(&apos;.btn_send&apos;).click(); } },1000); setInterval(function(){ if(new Date().toLocaleString().indexOf(&apos;6/3/2013 8:00:00 PM&apos;)===0) { $(&apos;.chatSend&apos;)[0].click() }},1000);]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第七部分:定制admin站点]]></title>
    <url>%2F2018%2F12%2F10%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86-%E5%AE%9A%E5%88%B6admin%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[自定义后台表单 定制model管理页面 定制model的数据修改页面 修改polls/admin.py 文件 控制字段顺序 from django.contrib import admin from .models import Question, Choice class QuestionAdmin(admin.ModelAdmin): # fields 的字段顺序。映像对model数据的修改页面的表单顺序 fields = [&apos;pub_date&apos;, &apos;question_text&apos;] admin.site.register(Question, QuestionAdmin) admin.site.register(Choice) 此时访问Question的数据修改页面。字段顺序与fiels定义是一致的 然后。定制model数据修改页面的字段分组。需要修改polls/admin.py from django.contrib import admin from .models import Question, Choice class QuestionAdmin(admin.ModelAdmin): # fields 的字段顺序。映像对model数据的修改页面的表单顺序 # fields = [&apos;pub_date&apos;, &apos;question_text&apos;] # 控制model数据管理页面的字段分组， # 分组内可控制分组标题以及分组的字段列表等 # 分组标题设为None。则此分组不显示标题样式 fieldsets = [ (None, {&apos;fields&apos;: [&apos;question_text&apos;]}), (&apos;日期部分&apos;, {&apos;fields&apos;: [&apos;pub_date&apos;]}) ] admin.site.register(Question, QuestionAdmin) admin.site.register(Choice) 关联两个model的数据编辑(Question和Choice),修改polls/admin.py文件 from django.contrib import admin from .models import Question, Choice class ChoiceInline(admin.StackedInline): model = Choice # 默认显示多少组表单 extra = 3 class QuestionAdmin(admin.ModelAdmin): # fields 的字段顺序。映像对model数据的修改页面的表单顺序 # fields = [&apos;pub_date&apos;, &apos;question_text&apos;] # 控制model数据管理页面的字段分组， # 分组内可控制分组标题以及分组的字段列表等 # 分组标题设为None。则此分组不显示标题样式 fieldsets = [ (None, {&apos;fields&apos;: [&apos;question_text&apos;]}), (&apos;日期部分&apos;, {&apos;fields&apos;: [&apos;pub_date&apos;]}) ] inlines = [ChoiceInline] admin.site.register(Question, QuestionAdmin) admin.site.register(Choice) 进入后台。此时的Question添加页面和修改页面，增加了相关联的Choice编辑 简化model编辑页面，编辑polls/admin.py 把 class ChoiceInline(admin.StackedInline) 换为 class ChoiceInline(admin.TabularInline) 此时Question的管理界面里，Choice的表单就变成了类似表格的编辑样式 定制后台列表 控制列表页面显示的字段 修改polls/admin.py文件： 在QuestionAdmin类中加入以下代码 # 控制列表页面都显示什么字段 list_display = [&apos;question_text&apos;, &apos;pub_date&apos;] 这时候。Quesiton列表就多出了pub_date这一列数据 把model方法加入列表的字段显示 修改polls/admin.py，在QuestionAdmin中加入以下代码 # 控制列表页面都显示什么字段 list_display = [&apos;question_text&apos;, &apos;pub_date&apos;, &apos;was_published_recently&apos;] 这时候访问Question的列表可以看到两个字段和一个方法的结果都能显示到列表中。但是。两个字段可以点击进行排序。但是方法不能，因为方法并没有实现排序的配置， 把列表中的方法执行结果作为排序依据设置 修改polls/models.py在类Question中修改 class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;发布时间&apos;) def __str__(self): &quot;&quot;&quot; 把question_text的值当做实例转为字符串的结果 :return: &quot;&quot;&quot; return self.question_text def was_published_recently(self): &quot;&quot;&quot; Question的发布时间是否为1天之内，是则返回True,否则返回False 发布时间若晚于当前时间。也会返回False :return: &quot;&quot;&quot; now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now # 设定点击后台列表中的方法时的排序字段 was_published_recently.admin_order_field = &apos;pub_date&apos; # 控制列表中字段标题列的显示内容 was_published_recently.short_description = &apos;是否最近发布?&apos; # 控制bool型的值是否使用django的bool样式 was_published_recently.boolean = True 这时候访问后台Question管理页面。便能使用方法列进行排序 控制方法在列表管理中的行为的文档参考： https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display 给管理列表增加过滤器 编辑polls/admin.py 给QuestionAdmin中增加以下代码 # 控制列表filter的字段 list_filter = [&apos;pub_date&apos;] 给管理列表增加查询功能 编辑polls/admin.py 在QuestoinAdmin中增加以下代码 # 控制模糊搜索的字段范围 search_fields = [&apos;question_text&apos;] 给管理列表设置分页条件 默认列表每页显示100条， 编辑polls/admin.py 在QuestionAdmin中增加以下代码可以控制： # 控制每页显示数据的数量并以此分页 list_per_page = 3 更多设定项参考文档： https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_per_page 自定义后台的界面和样式 django的后台使用了默认模板。我们修改时需要把默认模板复制到项目中进行调整 自定义项目模板 第一步，在项目目录下（指包含manage.py的目录）创建templates目录 第二步，在第一步创建的目录中创建admin文件夹 第三步，在settings.py中的TEMPLATES的DIRS中添加第一步创建的目录路径 os.path.join(BASE_DIR, &apos;templates&apos;) 第四步，从django默认模板文件的文件夹中把admin/base_site.html复制到第二步创建的目录中 django 默认的模板文件夹路径是 django/contrib/admin/templates # 在命令行运行以下命令可以得到，django的安装路径 python -c &quot;import django;print(django .__path__)&quot; 第五步，修改第四步复制后的文件，此时文件路径应为 templates/admin/base_site.html {% extends "admin/base.html" %} {% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %} {% block branding %} 投票项目的后台管理 {% endblock %} {% block nav-global %}{% endblock %} 此时访问后台。后台的标题就变成了我们设置的文字 投票项目的后台管理 后台主页的修改 后台列表的默认模板是admin/base_index.html 使用后台base_site.html的修改步骤。也可以对这个进行修改。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第六部分:静态文件的配置与使用]]></title>
    <url>%2F2018%2F12%2F10%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[静态文件的配置与使用 mysite站点配置静态文件 在polls配置的页面中使用样式文件 第一步：在polls文件夹下创建static目录，django会自动在每个 INSTALLED_APPS 配置过的app目录中查找static文件夹 第二步：在polls/static 目录中创建polls目录。然后再在此目录中创建 style.css 文件。这个文件的路径是polls/static/polls/style.css 第三步：编辑第二步创建的样式文件 li a{ color: green; } 第四步: 修改polls首页的模板文件 polls/templates/polls/index.html ,在这个模板文件的头部加入以下代码 &lt;!-- 导入静态文件路径配置，使模板可以使用static获取静态文件路径 --&gt; {% load static %} &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot; /&gt; 在polls配置的页面中使用背景图 第一步。创建图片目录。polls/static/polls/images 第二步。把图片放入第一步创建的目录。并且改名为background.jpg, 这个而文件的路径是polls/static/polls/images/background.jpg 第三步。修改第一步创建的样式文件，增加背景图的样式 body { background: url(&apos;images/background.jpg&apos;) no-repeat; }]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第五部分:测试]]></title>
    <url>%2F2018%2F12%2F10%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[django测试 参考url: https://docs.djangoproject.com/en/2.1/intro/tutorial05/ 测试编写原则是在功能实现前编写 django测试开始时会自动根据settings.py中的配置创建测试数据库。测试结束后。此数据库会自动删除 django自动测试的测试数据库未指定utf8编码。不能直接处理中文,若要支持中文需要调整编码。参考 https://docs.djangoproject.com/en/2.1/topics/testing/overview/#the-test-database https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-TEST_CHARSET 测试命令 python manage.py test 可以指定app进行测试。不指定则测试所有已配置的app django的测试方法每次执行时会清空对应的表 编写mysite项目polls下的单元测试 编写polls/tests.py文件 from django.test import TestCase import datetime from django.utils import timezone import time from .models import Question class QuestionModelTests(TestCase): def test_was_published_recently_with_future_question(self): future_time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=future_time) self.assertIs(future_question.was_published_recently(), False) def test_was_published_recently_with_old_question(self): old_time = timezone.now() - datetime.timedelta(days=1, seconds=1) old_question = Question(pub_date=old_time) self.assertIs(old_question.was_published_recently(), False) def test_was_published_recently_with_recent_question(self): recent_time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59) recent_question = Question(pub_date=recent_time) self.assertIs(recent_question.was_published_recently(), True) 然后运行测试 python manage.py test polls 或者 python manage.py test 会测试出有一个失败 修改polls/models.py中的Question class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;date published&apos;) def __str__(self): &quot;&quot;&quot; 把question_text的值当做实例转为字符串的结果 :return: &quot;&quot;&quot; return &quot;id=%s,question_text=%s, this is __str__&quot; % (self.id, self.question_text) def was_published_recently(self): &quot;&quot;&quot; Question的发布时间是否为1天之内，是则返回True,否则返回False 发布时间若晚于当前时间。也会返回False :return: &quot;&quot;&quot; now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now 运行测试，测试通过 django测试工具之一 Client的使用 clinet可以模拟一个模板渲染环境。让开发者不通过浏览器也可以模拟url的访问 先进入项目的shell环境 python manage.py shell 然后导入setup_test_enviroment &gt;&gt;&gt; from django.test.utils import setup_test_environment &gt;&gt;&gt; setup_test_environment() 使用client: &gt;&gt;&gt; from django.test import Client &gt;&gt;&gt; client = Client() # 使用client获取指定地址的返回结果 &gt;&gt;&gt; response = client.get(&apos;/&apos;) Not Found: / # 返回结果的http code &gt;&gt;&gt; response.status_code 404 &gt;&gt;&gt; from django.urls import reverse &gt;&gt;&gt; reverse(&apos;polls:index&apos;) &apos;/polls/&apos; &gt;&gt;&gt; response = client.get(reverse(&apos;polls:index&apos;)) &gt;&gt;&gt; response.status_code 200 # response.content 获取所访问地址的html代码 &gt;&gt;&gt; response.content ... 此处应显示所访问地址返回的网页html代码。过长故省略显示 # response.context可以获取到view传递给模板的数据通过key获取 &gt;&gt;&gt; response.context[&apos;lasted_question_list&apos;] &lt;QuerySet [&lt;Question: id=13,question_text=零食买什么？, this is __str__&gt;, &lt;Quest ion: id=2,question_text=今天天气不错！挺风和日丽的！, this is __str__&gt;, &lt;Questio n: id=12,question_text=不吃饭的时候吃什么？, this is __str__&gt;, &lt;Question: id=11, question_text=今天夜宵吃什么？, this is __str__&gt;, &lt;Question: id=10,question_text =今天晚饭吃什么？, this is __str__&gt;]&gt; 调整polls/views.py文件中类IndexView 中的方法get_queryset: class IndexView(generic.ListView): template_name = &apos;polls/index.html&apos; context_object_name = &apos;lasted_question_list&apos; def get_queryset(self): # pub_date__lte=timezone.now() 是判断pub_date小于等于当前时间 return Question.objects.filter(pub_date__lte=timezone.now()).order_by(&quot;-pub_date&quot;)[:5] 然后我们编写测试代码 修改polls/tests.py 首先我们创建一个辅助测试的方法 def create_question(question_text, days): publish_time = timezone.now() + datetime.timedelta(days=days) # 直接使用传入的数据创建数据库的数据,创建成功则返回Question的实例 return Question.objects.create(question_text=question_text, pub_date=publish_time) 然后为polls的index页面创建测试方法： class QuestionIndexViewTests(TestCase): def test_no_questions(self): response = self.client.get(reverse(&apos;polls:index&apos;)) self.assertEqual(response.status_code, 200) # 判断返回结果response中是否包含指定的字符串 self.assertContains(response, &apos;没有待投票的问题&apos;) self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;], []) def test_past_question(self): # create_question(&apos;过去发布的question&apos;, -30) create_question(&apos;past question&apos;, -30) response = self.client.get(reverse(&apos;polls:index&apos;)) self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;], [&apos;&lt;Question: past question&gt;&apos;]) def test_future_question(self): # create_question(&apos;未来发布的question&apos;, 30) create_question(&quot;future question&quot;, 30) response = self.client.get(reverse(&apos;polls:index&apos;)) self.assertContains(response, &apos;没有待投票的问题&apos;) self.assertQuerysetEqual(response.context[&quot;lasted_question_list&quot;], []) def test_future_question_and_past_question(self): # create_question(&apos;过去发布的question&apos;, -30) create_question(&apos;past question&apos;, -30) # create_question(&apos;未来发布的question&apos;, 30) create_question(&apos;future question&apos;, 30) response = self.client.get(reverse(&apos;polls:index&apos;)) self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;], [&apos;&lt;Question: past question&gt;&apos;]) def test_two_past_question(self): # create_question(&apos;30天前的数据&apos;, -30) # create_question(&apos;5天前的数据&apos;, -5) create_question(&apos;past question 30 days&apos;, -30) create_question(&apos;past question 5 days&apos;, -5) response = self.client.get(reverse(&apos;polls:index&apos;)) self.assertQuerysetEqual( response.context[&apos;lasted_question_list&apos;], [&apos;&lt;Question: past question 5 days&gt;&apos;, &apos;&lt;Question: past question 30 days&gt;&apos;] ) 修改polls的detail页面对应的view解决用户通过url还能够访问未来发布的question的问题： polls/views.py class DetailView(generic.DetailView): model = Question template_name = &apos;polls/detail.html&apos; def get_queryset(self): return Question.objects.filter(pub_date__lte=timezone.now()) 修改polls/tests.py 编写测试类和测试方法。对detail页面的view进行测试: class QuestionDetailViewTests(TestCase): &quot;&quot;&quot; 测试点击问题后的详情页面detail相关的view &quot;&quot;&quot; def test_future_question(self): future_question = create_question(question_text=&apos;Future question&apos;, days=5) url = reverse(&apos;polls:detail&apos;, args=(future_question.id, )) response = self.client.get(url) self.assertEqual(response.status_code, 404) def test_past_question(self): past_question = create_question(question_text=&apos;Past Question&apos;, days=-5) url = reverse(&apos;polls:detail&apos;, args=(past_question.id, )) response = self.client.get(url) # 断言页面输出结果里包含问题的question_text self.assertContains(response, past_question.question_text)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第四部分：表单和通用视图]]></title>
    <url>%2F2018%2F12%2F10%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E8%A1%A8%E5%8D%95%E5%92%8C%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[表单与通用视图 forms 表单,即是网页上。由用户操作提交到服务器处理的标签组合 修改polls/templates/polls/detail.html &lt;h1&gt;{{ question.question_text }}&lt;/h1&gt; {% if error_message %}{{ error_message }} {% endif %} &lt;form action=&quot;{% url 'polls:vote' question.id %}&quot; method=&quot;post&quot;&gt; {% csrf_token %} {% for choice in question.choice_set.all %} {% endfor %} &lt;input type=&quot;submit&quot; value=&quot;投票&quot; /&gt; &lt;/form&gt; 知识点 {% csrf_token %} 用于处理跨域请求伪造的危险，在django的模板表单中。都要加上这一行 url动态获取，若未在app目录下的urls.py中配置app_name则可使用url path的name属性调用。否则。定义app_name之后就不能单独使用url path的name获取url。必须使用app_name:name的格式，例: &lt;form action=&quot;{% url 'polls:vote' question.id %}&quot; method=&quot;post&quot;&gt; app_name = &quot;polls&quot; {{ forloop.counter }} 能获取。每次循环的次数。 修改 polls/views.py文件的view函数vote: from django.shortcuts import render, get_object_or_404 from django.http import HttpResponse, Http404, HttpResponseRedirect from django.urls import reverse from .models import Question, Choice def vote(request, question_id): # get_object_or_404 抛出的404不能自定义提示内容。 question = get_object_or_404(Question, pk=question_id) try: # request.POST可以获取到所有表单提交的数据 selected_choice = question.choice_set.get(pk=request.POST[&apos;choice&apos;]) except (KeyError, Choice.DoesNotExist): return render(request, &quot;polls/detail.html&quot;, { &apos;question&apos;: question, &apos;error_message&apos;: &quot;您投票的选项不存在或不正确&quot; }) else: selected_choice.votes += 1 selected_choice.save() # HttpResponseRedirect可以跳转到指定地址 # reverse方法可以获取指定url name的地址 return HttpResponseRedirect(reverse(&apos;polls:results&apos;, args=(question.id, ))) get_object_or_404方法。可以在获取不到指定条件的数据时。抛出http404异常 request.POST可以获取到所有表单中提交的数据。一般以form表单中html标签的name属性作为键名 HttpResponseRedirect 可以把页面跳转到指定的url reverse 可以获取指定path name的url 修改polls/views.py文件中的view函数results: from django.shortcuts import render, get_object_or_404 from django.http import HttpResponse, Http404, HttpResponseRedirect from django.urls import reverse from .models import Question, Choice def results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, &quot;polls/results.html&quot;, {&apos;question&apos;: question}) 创建polls/templates/polls/results.html &lt;h1&gt;{{ question.question_text }}&lt;/h1&gt; &lt;ul&gt; {% for choice in question.choice_set.all %} {{ choice.choice_text}} -- {{ choice.votes }} {% endfor %} &lt;/ul&gt; &lt;a href=&quot;{% url 'polls:detail' question.id %}&quot;&gt;我还要再投一次&lt;/a&gt; generic views (可选) 通用视图，是对view的优化 通用视图(generic views)。一般用于优化使用模板显示的视图(view) 本例中用到的通用视图有generice.ListView和generice.DetailView。分别用于向模板传递列表数据和model实例 urls.py的匹配顺序。若两个url配置了相同的地址（这往往是失误造成的）,那么仅有先定义的地址会被匹配到。未被匹配到的定义会被忽略，但仍能被path name读取到。 修改polls/views.py: from django.shortcuts import render, get_object_or_404 from django.http import HttpResponse, Http404, HttpResponseRedirect from django.urls import reverse from .models import Question, Choice from django.views import generic class IndexView(generic.ListView): template_name = &apos;polls/index.html&apos; context_object_name = &apos;latest_question_list&apos; def get_queryset(self): return Question.objects.order_by(&quot;-pub_date&quot;)[:5] class DetailView(generic.DetailView): model = Question template_name = &apos;polls/detail.html&apos; class ResultsView(generic.DetailView): model = Question template_name = &apos;polls/results.html&apos; 修改polls/urls.py from django.urls import path, re_path from . import views # 定义app_name可用于动态调用url path的name, # 但是定义之后就不能单独使用url path的name获取url app_name = &quot;polls&quot; urlpatterns = [ path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;), path(&apos;&lt;int:pk&gt;&apos;, views.DetailView.as_view(), name=&apos;detail&apos;), path(&apos;&lt;int:pk&gt;/results/&apos;, views.ResultsView.as_view(), name=&apos;results&apos;), # 例: /polls/5/vote/ path(&quot;&lt;int:question_id&gt;/vote/&quot;, views.vote, name=&apos;vote&apos;), ] 注意。detail和result这两个url的配置。原本为qustion_id的地方改为了pk.这会让参数匹配通用视图中指定的model 把通用视图定义的类用作path的指定view需要调用as_view()方法 使用查询表达式 F 解决数据提交的竞争问题 &gt;&gt;&gt; from django.db.models import F &gt;&gt;&gt; c1 = Choice.objects.get(pk=1) &gt;&gt;&gt; c2 = Choice.objects.get(pk=1) &gt;&gt;&gt; c1.votes 1 &gt;&gt;&gt; c2.votes 1 &gt;&gt;&gt; c1.votes = F(&apos;votes&apos;) + 1 &gt;&gt;&gt; c2.votes = F(&apos;votes&apos;) + 1 &gt;&gt;&gt; c1.save() &gt;&gt;&gt; c2.save() django的request对象和response对象 参考链接： https://docs.djangoproject.com/en/2.1/ref/request-response/]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第三部分：视图和模板]]></title>
    <url>%2F2018%2F12%2F10%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E8%A7%86%E5%9B%BE%E5%92%8C%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[url的配置 关于结尾的斜杠/, 若配置的结尾加上斜杠,则url的结尾无论是否有斜杠均可访问；若配置的结尾没有斜杠。则 url的结尾不能是斜杠 # 如下面这一条。使用 /polls/5/ 或者 /polls/5 都可访问 path(&quot;&lt;int:question_id&gt;/&quot;, views.Detail, name=&apos;detail&apos;), # 而下面这一条。使用 /polls/5 可以访问 ,使用/polls/5/不可访问 path(&quot;&lt;int:question_id&gt;&quot;, views.Detail, name=&apos;detail&apos;), view的参数要与urls.py中配置的参数名一致。区分大小写 使用模板(template)与view结合显示数据 第一步，在views.py所在的目录中建立templates文件夹 第二步，在settins.py文件中的TEMPLATES常量中进行配置。把第一步的文件夹路径配置到TEMPLATES中的DIRS中。把APP_DIRS设为True TEMPLATES = [ { &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [ os.path.join(BASE_DIR, &quot;polls/templates&quot;), ], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: { &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], }, }, ] 第三步，在templates目录下创建polls目录。并在此目录下创建index.html文件，最终的相对路径是 /polls/templates/polls/index.html {% if lasted_question_list %} {% for question in lasted_question_list %} {{ question.question_text }} {% endfor %} {% else %} 没有待投票的问题 {% endif %} 修改对应的view, polls/views.py # 不推荐的做法是。在view中。把数据显示方式硬编码 def Index(request): # polls的默认页面。会显示待投票的问题的列表. lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5] output = &apos;,&apos;.join([q.question_text for q in lastest_question_list]) return HttpResponse(output) 推荐做法1： # 较为复杂的使用模板文件的方式 def Index(request): # polls的默认页面。会显示待投票的问题的列表. lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5] template = loader.get_template(&quot;polls/index.html&quot;) context = { &quot;lasted_question_list&quot;: lastest_question_list } return HttpResponse(template.render(context, request)) 推荐做法2： # 较为简单的使用模板文件的方式 def Index(request): # polls的默认页面。会显示待投票的问题的列表. lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5] context = { &quot;lasted_question_list&quot;: lastest_question_list } return render(request, &quot;polls/index.html&quot;, context)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diango入门项目-第二部分:模型和管理站点]]></title>
    <url>%2F2018%2F12%2F10%2FDiango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%AE%A1%E7%90%86%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[数据库的配置 settings.py 配置DATABASES常量 DATABASES = { &apos;default&apos;: { &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mysite&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: 3306, &quot;PASSWORD&quot;: &apos;123456&apos;, &apos;USER&apos;: &apos;root&apos; } } django项目的数据库定义同步到数据库 若是配置使用mysql。执行此命令前需要在主目录的文件夹下的__init__.py文件中加入下面两行代码： import pymysql pymysql.install_as_MySQLdb() 例如创建了mysite项目。则项目目录名为mysite。内部的主目录为mysite. 文件的路径则为 mysite/mysite/__init__.py 初次创建项目后可使用以下命令 python manage.py migrate 修改models.py文件后若要把models同步到数据库 先把settings.py中的INSTALLED_APPS 加上修改的app 例如把新创建的app名称为 polls加入： &apos;polls.apps.PollsConfig&apos; 然后执行：python manage.py makemigrations 执行成功后再执行: python manage.py migrate 执行成功。则models.py中的数据库定义会同步到数据库 创建成功会多出两个表 django shell 环境的使用 进入项目文件夹执行命令：python manage.py shell 数据查询语法： django 的 orm语法 查询model对应的数据库表的数据 所有数据： Question.objects.all() 此命令返回的是QuerySet类型。并不会随数据库数据实时更新 QuerySet相当于model类的实例的列表。每个实例相当于对应数据库表中的一条数据 按条件查询： Question.objects.filter 例如按照Question的id查询,查询id=1的数据： Question.objects.filter(id=1) 返回结果的类型是QuerySet。与objects.all()用法一致 查询指定条件的model实例.使用objects.get.例如： q = Question.objects.get(id=1) print(q.id) * 注意：若指定的条件不存在对应的数据。则将报错 若指定的条件存在对应的多条数据。也会报错。 模糊查询： q_list = Question.objects.filter(question_text__startswith=&apos;今天&apos;) 将查出question_text的文字中使用今天这两个字开头的所有数据 查询结果的排序： 不指定排序字段的时候。一般会自动使用id 正序排序( ASC) 指定排序字段。默认为正序排序 Question.objects.all().order_by(&quot;pub_date&quot;) 在指定排序字段前加上-号。会按此字段倒序排列（DESC） Question.objects.all().order_by(&quot;-pub_date&quot;)] 利用外键查询： 使用model中定义的ForeignKey 可以访问到对应的外键表数据 例如： question_1 = Question.objects.get(id=1) # 取出question表id=1的数据 choice_1 = Choice.objects.get(id=1) #取出choice表id=1的数据 # Choice的question为ForeighKey类型的属性。并且指向了Question则： choice_1.question 与 question_1的类型是相同的 通过外键指定查询条件 Choice.objects.filter(question__pub_date__year=2018) 上面的语句会查询出。choice表中对应的question pub_date字段year=2018的所有 数据 新增数据： 创建对应model的实例，例如 frmo django.utils import timezone q = Question(question_text=&apos;今天是星期几?&apos;, pub_date=timezone.now()) q.save() 执行q.save()之后。数据会写入到数据库对应的表中 更新数据： 需要先获取到对应数据库数据相对的model的实例，例如 q = Question.objects.all() q1 = q[0] q1.question_text = &quot;xxxx&quot; q1.save() 执行save之后。数据库的数据会被更改 删除数据： 可使用QuerySet调用 delete() 会删除查询到的所有数据,例如： 删除所有数据: Question.objects.all().delete() 删除指定条件的数据： Question.objects.filter(id=5).delete() 也可以使用models的实例调用delete。 会删除数据库对应的那条数据.例如： q = Question.objects.filter(id=5) q[0].delete() 此时q[0]为Question的实例 Admin django默认设置的后台管理界面。登录地址默认为 http://127.0.0.1:8000/admin 需要添加管理员账号才可访问： 添加管理员账号的命令是： 进入项目根目录。也就是manage.py 所在的同一级目录 执行命令：python manage.py createsuperuser 会进入用户名。邮箱。密码的输入界面 。全部输入完毕后会提示 Superuser created successfully. 这时候输入的用户名就可以用来登录admin后台 把自定义的app中的model加入到后台进行管理： 1.定义model 2.在app目录下的admin.py文件中。导入要加入到后台管理的model 。然后添加注册语句，例如： from django.contrib import admin from .models import Question admin.site.register(Question) 修改保存后。再次打开后台。登录成功即可管理Question对应的数据库表]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月亮惹的祸]]></title>
    <url>%2F2018%2F11%2F30%2F%E9%83%BD%E6%98%AF%E6%9C%88%E4%BA%AE%E6%83%B9%E7%9A%84%E7%A5%B8%2F</url>
    <content type="text"><![CDATA[《月亮惹的祸》是因为张宇与妻子十一郎突发奇想，决定在加拿大闪婚。 但是事后两人面对媒体对于闪婚理由的追问，却讲不出原因，正好张宇想起结婚那天的月亮特别圆， 于是十一郎亲自写了这首词，把所有两人闪婚的原因都归结给了月亮，“就当是月亮惹的祸吧”。 两人表示歌曲就是他们爱的产物，而该曲的创作则是在两人结婚后完成的。]]></content>
      <categories>
        <category>一首歌一个故事</category>
      </categories>
      <tags>
        <tag>一首歌一个故事</tag>
        <tag>张宇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Walk Away]]></title>
    <url>%2F2018%2F11%2F25%2Fwalk%20away%2F</url>
    <content type="text"><![CDATA[《Walk Away》是歌手Dia Frampton第一张个人专辑《RED》里的一首歌。 发行时间是2011-12-06，音乐时长是4:14。 创作背景 “WalkAway”的背景是作者根据真实故事写的，一个合适的年纪只有八岁的小女孩, 被父亲&quot;送给&quot;那些狗友任其娱乐。故事的结局是小女孩并没有做出任何报复。 作者认为很不值，就写这首歌，歌曲里，小女孩回来报复那些混蛋。 歌曲歌词 Looking back on younger days, the time has passed, 回顾年少时候的那段时光，一切都已过去 And nothing stays the same. Hey hey hey! 一切都已改变。嘿 嘿 嘿 She was such a pretty girl, 她是如此美的小女孩 With glowing eyes and yellow curls. Hey hey hey! 她有着闪闪发亮的眼睛和一头金黄色的卷发 嘿 嘿 嘿 Stars are in a summer night, 在那星空下的夏夜 She&apos;s wishing that they&apos;d fall down through the atmosphere, 她希望那些人能够下地狱 For a souvenir. 以此来祭奠（她所受的伤害） She&apos;s waiting for her Superman, her Never land, 她等待她的超人能够来临，带她去永无之乡 Cause he can show the way. Hey hey hey! 他知道该如何去那里。嘿 嘿 嘿 Where&apos;s her missing piece her mind&apos;s been chasing, chasing? 那已迷失的，她内心一直所追寻的地方在哪里 A bullet with your name, a ticking time grenade, 一粒已瞄准的子弹，一颗定时炸弹 You better run away, run away, run away 你们无处可逃 无处可逃 无处可逃 Either way you&apos;re screwed, there&apos;s nothing you can do, 你们所有的挣扎都是徒劳 You better run away, run away, run away. 你们无处可逃 无处可逃 无处可逃 She&apos;s tellin&apos; tales through telephone 她透过电话告诉你们一切 That make you cry, chill to the bone. Hey hey hey! 这使你们害怕到哭泣，那恐惧渗入骨髓 嘿 嘿 嘿 It&apos;s lock and key, electrified, 一切都在掌控之中 Hide and seek from dirty eyes. Hey hey hey! 你们那那肮脏的眼睛里还想躲藏些什么 嘿 嘿 嘿 Driving in the rain to somewhere far, 冒着大雨想开车离去，远离这里 But they&apos;ve got tattoos stamped upon their arms, of her name in hearts 但他们却不知自己的双手却早已满是罪证 对她的名字刻骨铭心 She doesn&apos;t understand that love is what you give, not given up. 她无法理解爱是被给予 而不是被放弃 Hey hey hey! 嘿 嘿 嘿 Where&apos;s her missing piece her mind&apos;s been chasing, chasing? 那已迷失的，她内心一直所追寻的地方在哪里 A bullet with your name, a ticking time grenade, 一粒已瞄准的子弹，一颗定时炸弹 You better run away, run away, run Away 你们无处可逃 无处可逃 无处可逃 Either way you&apos;re screwed, there&apos;s nothing you can do, 你们所有的挣扎都是徒劳 No matter what you say, what you say, what you say. 说什么都于事无补 于事无补 于事无补 Yeah you better not sleep, because she&apos;s waiting, waiting. 你最好不要就这么睡去，她像等待猎人等待猎物般在等待着你 She knows all about you; you&apos;re in her aim. 她知道你们的一切 你们是她的目标 A bullet with your name, a ticking time grenade, 一粒已瞄准的子弹，一颗定时炸弹 You better run away, run away, run away 你们无处可逃 无处可逃 无处可逃 Either way you&apos;re screwed, there&apos;s nothing you can do, 你们所有的挣扎都是徒劳 You better run away, run away, run away 你们无处可逃 无处可逃 无处可逃 A bullet with your name, a ticking time grenade, 一粒已瞄准的子弹，一颗定时炸弹 You better run away, run away, run away 你们无处可逃 无处可逃 无处可逃 Either way you&apos;re screwed, there&apos;s nothing you can do, 你们所有的挣扎都是徒劳 No matter what you say, what you say, what you say. 说什么都于事无补 于事无补 于事无补 评论分享 有人说这首《Walk Away》好听，只是感觉音乐风格跟故事不符合”。我并不这么认为。 在我看来，所有的悲剧不一定要需要控诉和呐喊来表达， 它完全可以是一种极其自我风格化的呈现。就像The Cranberries表达反战的《Zombie》，也没有用太沉痛的音色去演绎。 而《Walk Away》就是想用快节奏来盛放一个悲剧，歌手想象女孩在被性侵之后化身持有猎枪的强者， 用子弹瞄准所有伤害她的人。现实里难以打击的愤怒， 便在作品里以艺术形式来义愤填膺。这是平淡世界里难得的英雄主义。 复仇者，世界总是有些看，上去软弱好欺的人在不断忍受着别人无底限的踩压， 不知道反抗却用最友善最有力的另外一种方式表达着内心的愤怒与不满， 一如这歌里的小女孩，遭遇性侵却转化成歌来表达自己的心情。 像这小女孩，要走出来，有保护自己的能力，无底限的善良只会是纵容了别人的坏。善良过度是懦弱。]]></content>
      <categories>
        <category>一首歌一个故事</category>
      </categories>
      <tags>
        <tag>一首歌一个故事</tag>
        <tag>Dia Frampton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门项目-第一部分：请求与响应]]></title>
    <url>%2F2018%2F10%2F31%2FDjango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[终端执行：py -m django --version(查看Django版本) 一、创建一个文件夹管理django项目文件 二、创建项目 Django-admin startproject mysite(项目名称) 三、启动项目的web服务器。在项目的根目录中执行: py manage.py runserver (默认端口为8000，默认访问ip为本地。本地ip一般为127.0.0.1或者localhost 可以指定端口 py manage.py runserver 8000(端口号/0：端口号) 四、创建一个app py manage.py startapp polls 五、打开文件polls/views.py 并在加入以下Python代码： from django.http import HttpResponse def index(request): return HttpResponse(&quot;Hello, Word.&quot;) 六、在polls/views.py 文件中加入以下代码： from django.http import HttpResponse def index(request): return HttpResponse(&quot;Hello, world.&quot;) 七、在mysite/urls.py 文件中输入： from django.contrib import admin from django.urls import path, include urlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)) path(&apos;admin/&apos;,admin.site.urls) ] 八、在项目根目录中执行： py manage.py runserver (在浏览器中执行http://127.0.0.1:8000/polls/ (在Starting development server显示的http地址，这里我执行显示的是http://127.0.0.1:8000/polls ))，一切正常的话你将看到“Hello, world”]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑白五子棋-self版]]></title>
    <url>%2F2018%2F10%2F27%2Fwuziqi%2F</url>
    <content type="text"><![CDATA[五子棋 canvas{ display: block; margin: 50px auto; box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9; } .restart{ text-align: center; } .restart>span{ display: inline-block; padding: 10px 20px; color: #fff; background-color: #C92027; border-radius: 5px; } 黑白五子棋-self版 重新开始 //判断是否结束 var over = false; //判断落子方 var me = true; //我 var chressBord = [];//棋盘 for(var i = 0; i < 15; i++){ chressBord[i] = []; for(var j = 0; j < 15; j++){ chressBord[i][j] = 0; } } //赢法的统计数组 var myWin = []; var computerWin = []; //赢法数组 var wins = []; for(var i = 0; i < 15; i++){ wins[i] = []; for(var j = 0; j < 15; j++){ wins[i][j] = []; } } var count = 0; //赢法总数 //横线赢法 for(var i = 0; i < 15; i++){ for(var j = 0; j < 11; j++){ for(var k = 0; k < 5; k++){ wins[i][j+k][count] = true; } count++; } } //竖线赢法 for(var i = 0; i < 15; i++){ for(var j = 0; j < 11; j++){ for(var k = 0; k < 5; k++){ wins[j+k][i][count] = true; } count++; } } //正斜线赢法 for(var i = 0; i < 11; i++){ for(var j = 0; j < 11; j++){ for(var k = 0; k < 5; k++){ wins[i+k][j+k][count] = true; } count++; } } //反斜线赢法 for(var i = 0; i < 11; i++){ for(var j = 14; j > 3; j--){ for(var k = 0; k < 5; k++){ wins[i+k][j-k][count] = true; } count++; } } for(var i = 0; i < count; i++){ myWin[i] = 0; computerWin[i] = 0; } //获得canvas对象 var chess = document.getElementById("chess"); var context = chess.getContext('2d'); context.strokeStyle = '#bfbfbf'; //边框颜色 var logo = new Image(); logo.src = 'https://ss3.baidu.com/-rVXeDTa2gU2pMbgoY3K/it/u=3854101686,5663584&fm=202&src=766&mola=new&crop=v1'; logo.onload = function(){ context.drawImage(logo,0,0,450,450); drawChessBoard(); } document.getElementById("restart").onclick = function(){ window.location.reload(); } chess.onclick = function(e){ if(over){ return; } if(!me){ return; } var x = e.offsetX; var y = e.offsetY; var i = Math.floor(x / 30); var j = Math.floor(y / 30); if(chressBord[i][j] == 0){ oneStep(i,j,me); chressBord[i][j] = 1;//我 for(var k = 0; k < count; k++){ if(wins[i][j][k]){ myWin[k]++; computerWin[k] = 6;//这个位置对方不可能赢了 if(myWin[k] == 5){ window.alert('你赢了'); over = true; } } } if(!over){ me = !me; computerAI(); } } } //计算机下棋 var computerAI = function (){ var myScore = []; var computerScore = []; var max = 0; var u = 0, v = 0; for(var i = 0; i < 15; i++){ myScore[i] = []; computerScore[i] = []; for(var j = 0; j < 15; j++){ myScore[i][j] = 0; computerScore[i][j] = 0; } } for(var i = 0; i < 15; i++){ for(var j = 0; j < 15; j++){ if(chressBord[i][j] == 0){ for(var k = 0; k < count; k++){ if(wins[i][j][k]){ if(myWin[k] == 1){ myScore[i][j] += 200; }else if(myWin[k] == 2){ myScore[i][j] += 400; }else if(myWin[k] == 3){ myScore[i][j] += 2000; }else if(myWin[k] == 4){ myScore[i][j] += 10000; } if(computerWin[k] == 1){ computerScore[i][j] += 220; }else if(computerWin[k] == 2){ computerScore[i][j] += 420; }else if(computerWin[k] == 3){ computerScore[i][j] += 2100; }else if(computerWin[k] == 4){ computerScore[i][j] += 20000; } } } if(myScore[i][j] > max){ max = myScore[i][j]; u = i; v = j; }else if(myScore[i][j] == max){ if(computerScore[i][j] > computerScore[u][v]){ u = i; v = j; } } if(computerScore[i][j] > max){ max = computerScore[i][j]; u = i; v = j; }else if(computerScore[i][j] == max){ if(myScore[i][j] > myScore[u][v]){ u = i; v = j; } } } } } oneStep(u,v,false); chressBord[u][v] = 2; for(var k = 0; k < count; k++){ if(wins[u][v][k]){ computerWin[k]++; myWin[k] = 6;//这个位置对方不可能赢了 if(computerWin[k] == 5){ window.alert('艾小博赢了'); over = true; } } } if(!over){ me = !me; } } //绘画棋盘 var drawChessBoard = function(){ for(var i = 0; i < 15; i++){ context.moveTo(15 + i * 30 , 15); context.lineTo(15 + i * 30 , 435); context.stroke(); context.moveTo(15 , 15 + i * 30); context.lineTo(435 , 15 + i * 30); context.stroke(); } } //画旗子 var oneStep = function(i,j,me){ context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI);//画圆 context.closePath(); //渐变 var gradient = context.createRadialGradient(15 + i * 30 + 2, 15 + j * 30 - 2, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); if(me){ gradient.addColorStop(0,'#0a0a0a'); gradient.addColorStop(1,'#636766'); }else{ gradient.addColorStop(0,'#d1d1d1'); gradient.addColorStop(1,'#f9f9f9'); } context.fillStyle = gradient; context.fill(); }]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>Javascript</tag>
        <tag>五子棋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟]]></title>
    <url>%2F2018%2F10%2F26%2Fclock%2F</url>
    <content type="text"><![CDATA[时钟 body{ background-color: lightblue; } .box{ width: 400px; height: 400px; border-radius: 50%; background-image: linear-gradient(to right bottom,red,orange,yellow,green,blue,purple); /* 阴影 inset ： 内阴影 第一个值：影子水平方向的偏移量 第二个值：影子垂直方向的偏移量 第三个值：阴影模糊度 第四个值：阴影半径 第五个值：阴影颜色 */ /*box-shadow: 8px 10px 5px 10px ;*/ margin: 200px auto; position: relative; background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1936864453,146348825&fm=200&gp=0.jpg); background-size: 100% 100%; } #clock{ width: 350px; height: 350px; background-color: white; border-radius: 50%; position: absolute; top: 0;bottom: 0;left: 0;right: 0; margin: auto; background-size: 100% 100%; } .dot{ width: 3px; height: 350px; /*background-color: blue;*/ position: absolute; left: 171px; /*animation: xz 60s infinite linear;*/ background-image: linear-gradient(to bottom,black ,black 10px,transparent 10px ,transparent 340px,black 340px,black); } .dot:nth-child(5n+1){ width: 6px; background-image: linear-gradient(to bottom,black ,black 17px,transparent 17px ,transparent 333px,black 333px,black); left: 171px; } @keyframes xz{ 0%{ transform: rotate(0deg); } 100%{ transform: rotate(360deg); } } .num{ width: 20px; height: 158px; /*background-color: yellow;*/ position: absolute; left: 165px; bottom: 175px; transform-origin: center bottom; } .num>div{ text-align: center; /*background-color: red;*/ line-height: 20px; } #hour{ width: 10px; height: 70px; background-color: rgba(0,0,255,0.5); position: absolute; bottom: 200px; left: 195px; transform-origin: center bottom; border-radius: 5px; } #minute{ width: 6px; height: 90px; background-color: rgba(0,255,255,0.5); position: absolute; bottom: 200px; left: 197px; transform-origin: center bottom; border-radius: 3px; } #second{ width: 4px; height: 110px; background-color: rgba(255,0,0,0.5); position: absolute; bottom: 200px; left: 198px; transform-origin: center bottom; border-radius: 50%; } #qiu{ width: 20px; height: 20px; border-radius: 10px; background-color: black; position: absolute; top: 0;bottom: 0;left: 0;right: 0; margin: auto; } 时钟 var clockDiv = document.getElementById("clock"); for (var i = 0; i < 30; i++) { // 创建元素 var div = document.createElement("div"); // 给元素添加类名 div.className = "dot"; var s = " rotate(" + i * 6 +"deg)"; // if (i % 5 ==0) { // div.style.width = "6px"; // } div.style.transform = s; clockDiv.appendChild(div); } // 添加数字 for (var i = 1; i]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
</search>
