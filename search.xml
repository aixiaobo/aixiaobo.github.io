<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>HEXO博客添加在线联系功能</title>
      <link href="/2018/12/15/HEXO%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/12/15/HEXO%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。</p><p>最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/KEDeoi.rYGiGJS7VmUiJ*meM.Wa8ZzOL3oiA6OMa7Uc!/b/dLYAAAAAAAAA&bo=pwCMAAAAAAADBwk!&rf=viewer_4"></p><p>配置方法如下:<br>首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/OmyCu0WT.DNnb1abSOl.WkraCmlpTbS9Afr*Ca67GEw!/b/dLkAAAAAAAAA&bo=cgMoAgAAAAADJ1k!&rf=viewer_4"></p><pre><code>以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下：{% if theme.daovoice %}<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")daovoice('init', {      app_id: "{{theme.daovoice_app_id}}"    });    daovoice('update');    </script>{% endif %} </code></pre><p>接着打开主题配置文件_config.yml，添加如下代码：</p><pre><code># Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id</code></pre><p>最后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。</p><p>需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/Fp1rXEXgOP6uIhgTYMlb3btiIK0UKcEj09akffZhElI!/b/dL0AAAAAAAAA&bo=dQPMAAAAAAADF4g!&rf=viewer_4"></p><p>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/6.pPXuRfw00q8rLzvJoSiQHBEbRkOYkXhTw8RO72KTk!/b/dL4AAAAAAAAA&bo=awPOAgAAAAADF5Y!&rf=viewer_4"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python实现图片转字符串</title>
      <link href="/2018/12/14/python%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/14/python%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<pre><code>1.安装pillow库在终端执行：pip install pillow2.打开代码编辑器（最好使用pycharm）from PIL import Image  IMG=&apos;D:\Code\python\\test1\\ascii_dora.png&apos;  WIDTH=60  HEIGHT=45  ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;)  #将256灰度映射到70个字符上  def get_char(r,g,b,alpha=256):#alpha透明度      if alpha==0:          return &apos; &apos;      length=len(ascii_char)      gray=int(0.2126*r+0.7152*g+0.0722*b)#计算灰度      unit=(256.0+1)/length      return ascii_char[int(gray/unit)]#不同的灰度对应着不同的字符      #通过灰度来区分色块  if __name__==&apos;__main__&apos;:      im=Image.open(IMG)      im=im.resize((WIDTH,HEIGHT),Image.NEAREST)      txt=&quot;&quot;      for i in range(HEIGHT):          for j in range(WIDTH):              txt+=get_char(*im.getpixel((j,i)))          txt+=&apos;\n&apos;      print (txt)      #写入文件    with open(&quot;output.txt&quot;,&apos;w&apos;) as f:          f.write(txt)第二种方法：    from PIL import Image    codeLib = &apos;&apos;&apos;@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,&quot;^`&apos;. &apos;&apos;&apos;#生成字符画所需的字符集    count = len(codeLib)    def transform1(image_file):        image_file = image_file.convert(&quot;L&quot;)#转换为黑白图片，参数&quot;L&quot;表示黑白模式        codePic = &apos;&apos;        for h in range(0,image_file.size[1]):  #size属性表示图片的分辨率，&apos;0&apos;为横向大小，&apos;1&apos;为纵向            for w in range(0,image_file.size[0]):                gray = image_file.getpixel((w,h)) #返回指定位置的像素，如果所打开的图像是多层次的图片，那这个方法就返回一个元组                codePic = codePic + codeLib[int(((count-1) * gray) / 256)]#建立灰度与字符集的映射            codePic = codePic + &apos;\r\n&apos;        return codePic    def transform2(image_file):        codePic = &apos;&apos;        for h in range(0,image_file.size[1]):            for w in range(0,image_file.size[0]):                g,r,b = image_file.getpixel((w,h))                gray = int(r * 0.299 + g * 0.587+b * 0.114)                codePic = codePic + codeLib[int(((count-1) * gray)/256)]            codePic = codePic+&apos;\r\n&apos;        return codePic    fp = open(u&apos;11.png&apos;,&apos;rb&apos;)    image_file = Image.open(fp)    image_file=image_file.resize((int(image_file.size[0] * 0.25), int(image_file.size[0] * 0.15)))#调整图片大小    tmp = open(&apos;tmp.txt&apos;,&apos;w&apos;)    tmp.write(transform1(image_file))    tmp.close()</code></pre><p>这是原图<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/4aLK4t7fvxVItnY7WwFQdSfDY37rgQV*qvXcbdnxgDE!/b/dLkAAAAAAAAA&bo=vALaBLwC2gQKGTU!&rf=viewer_4" width="600px" height="500px"></p><p>这是效果图<br><img src="http://m.qpic.cn/psb?/V10FYvF64cCkdZ/9iNebR0n.LfkW9AULX7tscxX6ePhmyGd31G3NSqutak!/b/dDUBAAAAAAAA&bo=yAS1A8gEtQMDCSw!&rf=viewer_4"></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网页版微信定时自动给好友发消息</title>
      <link href="/2018/12/14/%E5%BE%AE%E4%BF%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E6%B6%88%E6%81%AF/"/>
      <url>/2018/12/14/%E5%BE%AE%E4%BF%A1%E5%AE%9A%E6%97%B6%E8%87%AA%E5%8A%A8%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<pre><code>操作步骤：    1.登陆网页版微信    2.打开开发者工具（F12）    3.打开 console 控制台    4.粘贴一下代码到控制台并回车实现原理：    1.遍历好友列表    2.修改输入框文本    3.点击发送源代码：    循环发送（每隔3秒发送一次）：        function show(){        $(&apos;.edit_area&apos;).html(&apos;需要发送的文字&apos;);        $(&quot;.edit_area&quot;).trigger($.Event(&quot;keydown&quot;, { keyCode: 13,ctrlKey: true}));        $(&apos;.btn_send&apos;).click();        }        var sh;        sh=setInterval(show,3000);         clearInterval(sh);  //这行用来停止发送        new Date().toLocaleString()， //回车，查看输出的信息；    定时发送（需注意日期格式）:        setInterval(function(){        if(new Date().toLocaleString().indexOf(&apos;2015/8/31 下午4:02:00&apos;)===0)        {        $(&apos;.edit_area&apos;).html(&apos;需要发送的文字&apos;);        $(&quot;.edit_area&quot;).trigger($.Event(&quot;keydown&quot;, { keyCode: 13,ctrlKey: true}));        $(&apos;.btn_send&apos;).click();        }        },1000);        setInterval(function(){ if(new Date().toLocaleString().indexOf(&apos;6/3/2013 8:00:00 PM&apos;)===0) { $(&apos;.chatSend&apos;)[0].click() }},1000);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑科技 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第七部分:定制admin站点</title>
      <link href="/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86-%E5%AE%9A%E5%88%B6admin%E7%AB%99%E7%82%B9/"/>
      <url>/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86-%E5%AE%9A%E5%88%B6admin%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre><code>自定义后台表单定制model管理页面定制model的数据修改页面修改polls/admin.py 文件 控制字段顺序from django.contrib import adminfrom .models import Question, Choiceclass QuestionAdmin(admin.ModelAdmin):    # fields 的字段顺序。映像对model数据的修改页面的表单顺序    fields = [&apos;pub_date&apos;, &apos;question_text&apos;]admin.site.register(Question, QuestionAdmin)admin.site.register(Choice)此时访问Question的数据修改页面。字段顺序与fiels定义是一致的然后。定制model数据修改页面的字段分组。需要修改polls/admin.pyfrom django.contrib import adminfrom .models import Question, Choiceclass QuestionAdmin(admin.ModelAdmin):    # fields 的字段顺序。映像对model数据的修改页面的表单顺序    # fields = [&apos;pub_date&apos;, &apos;question_text&apos;]    # 控制model数据管理页面的字段分组，    # 分组内可控制分组标题以及分组的字段列表等    # 分组标题设为None。则此分组不显示标题样式    fieldsets = [        (None, {&apos;fields&apos;: [&apos;question_text&apos;]}),        (&apos;日期部分&apos;, {&apos;fields&apos;: [&apos;pub_date&apos;]})    ]admin.site.register(Question, QuestionAdmin)admin.site.register(Choice)关联两个model的数据编辑(Question和Choice),修改polls/admin.py文件from django.contrib import adminfrom .models import Question, Choiceclass ChoiceInline(admin.StackedInline):    model = Choice    # 默认显示多少组表单    extra = 3class QuestionAdmin(admin.ModelAdmin):    # fields 的字段顺序。映像对model数据的修改页面的表单顺序    # fields = [&apos;pub_date&apos;, &apos;question_text&apos;]    # 控制model数据管理页面的字段分组，    # 分组内可控制分组标题以及分组的字段列表等    # 分组标题设为None。则此分组不显示标题样式    fieldsets = [        (None, {&apos;fields&apos;: [&apos;question_text&apos;]}),        (&apos;日期部分&apos;, {&apos;fields&apos;: [&apos;pub_date&apos;]})    ]    inlines = [ChoiceInline]admin.site.register(Question, QuestionAdmin)admin.site.register(Choice)进入后台。此时的Question添加页面和修改页面，增加了相关联的Choice编辑简化model编辑页面，编辑polls/admin.py把 class ChoiceInline(admin.StackedInline)换为class ChoiceInline(admin.TabularInline)此时Question的管理界面里，Choice的表单就变成了类似表格的编辑样式定制后台列表控制列表页面显示的字段修改polls/admin.py文件： 在QuestionAdmin类中加入以下代码    # 控制列表页面都显示什么字段    list_display = [&apos;question_text&apos;, &apos;pub_date&apos;]这时候。Quesiton列表就多出了pub_date这一列数据把model方法加入列表的字段显示修改polls/admin.py，在QuestionAdmin中加入以下代码# 控制列表页面都显示什么字段list_display = [&apos;question_text&apos;, &apos;pub_date&apos;, &apos;was_published_recently&apos;]这时候访问Question的列表可以看到两个字段和一个方法的结果都能显示到列表中。但是。两个字段可以点击进行排序。但是方法不能，因为方法并没有实现排序的配置，把列表中的方法执行结果作为排序依据设置修改polls/models.py在类Question中修改class Question(models.Model):    question_text = models.CharField(max_length=200)    pub_date = models.DateTimeField(&apos;发布时间&apos;)    def __str__(self):        &quot;&quot;&quot;        把question_text的值当做实例转为字符串的结果        :return:        &quot;&quot;&quot;        return self.question_text    def was_published_recently(self):        &quot;&quot;&quot;        Question的发布时间是否为1天之内，是则返回True,否则返回False        发布时间若晚于当前时间。也会返回False        :return:        &quot;&quot;&quot;        now = timezone.now()        return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now    # 设定点击后台列表中的方法时的排序字段    was_published_recently.admin_order_field = &apos;pub_date&apos;    # 控制列表中字段标题列的显示内容    was_published_recently.short_description = &apos;是否最近发布?&apos;    # 控制bool型的值是否使用django的bool样式    was_published_recently.boolean = True这时候访问后台Question管理页面。便能使用方法列进行排序 控制方法在列表管理中的行为的文档参考： https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display给管理列表增加过滤器编辑polls/admin.py 给QuestionAdmin中增加以下代码    # 控制列表filter的字段    list_filter = [&apos;pub_date&apos;]给管理列表增加查询功能编辑polls/admin.py 在QuestoinAdmin中增加以下代码    # 控制模糊搜索的字段范围    search_fields = [&apos;question_text&apos;]给管理列表设置分页条件默认列表每页显示100条， 编辑polls/admin.py 在QuestionAdmin中增加以下代码可以控制：    # 控制每页显示数据的数量并以此分页    list_per_page = 3更多设定项参考文档： https://docs.djangoproject.com/zh-hans/2.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_per_page自定义后台的界面和样式django的后台使用了默认模板。我们修改时需要把默认模板复制到项目中进行调整自定义项目模板第一步，在项目目录下（指包含manage.py的目录）创建templates目录第二步，在第一步创建的目录中创建admin文件夹第三步，在settings.py中的TEMPLATES的DIRS中添加第一步创建的目录路径os.path.join(BASE_DIR, &apos;templates&apos;)第四步，从django默认模板文件的文件夹中把admin/base_site.html复制到第二步创建的目录中 django 默认的模板文件夹路径是 django/contrib/admin/templates# 在命令行运行以下命令可以得到，django的安装路径python -c &quot;import django;print(django.__path__)&quot;第五步，修改第四步复制后的文件，此时文件路径应为 templates/admin/base_site.html{% extends "admin/base.html" %}{% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}{% block branding %}<h1 id="site-name"><a href="{% url 'admin:index' %}">投票项目的后台管理</a></h1>{% endblock %}{% block nav-global %}{% endblock %}此时访问后台。后台的标题就变成了我们设置的文字 投票项目的后台管理后台主页的修改后台列表的默认模板是admin/base_index.html 使用后台base_site.html的修改步骤。也可以对这个进行修改。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第六部分:静态文件的配置与使用</title>
      <link href="/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>静态文件的配置与使用mysite站点配置静态文件在polls配置的页面中使用样式文件第一步：在polls文件夹下创建static目录，django会自动在每个 INSTALLED_APPS 配置过的app目录中查找static文件夹第二步：在polls/static 目录中创建polls目录。然后再在此目录中创建 style.css 文件。这个文件的路径是polls/static/polls/style.css第三步：编辑第二步创建的样式文件li a{    color: green;}第四步: 修改polls首页的模板文件 polls/templates/polls/index.html ,在这个模板文件的头部加入以下代码&lt;!-- 导入静态文件路径配置，使模板可以使用static获取静态文件路径 --&gt;{% load static %}&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot; /&gt;在polls配置的页面中使用背景图第一步。创建图片目录。polls/static/polls/images第二步。把图片放入第一步创建的目录。并且改名为background.jpg, 这个而文件的路径是polls/static/polls/images/background.jpg第三步。修改第一步创建的样式文件，增加背景图的样式body {    background: url(&apos;images/background.jpg&apos;) no-repeat;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第五部分:测试</title>
      <link href="/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<pre><code>django测试参考url: https://docs.djangoproject.com/en/2.1/intro/tutorial05/测试编写原则是在功能实现前编写django测试开始时会自动根据settings.py中的配置创建测试数据库。测试结束后。此数据库会自动删除django自动测试的测试数据库未指定utf8编码。不能直接处理中文,若要支持中文需要调整编码。参考 https://docs.djangoproject.com/en/2.1/topics/testing/overview/#the-test-database https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-TEST_CHARSET测试命令 python manage.py test 可以指定app进行测试。不指定则测试所有已配置的appdjango的测试方法每次执行时会清空对应的表编写mysite项目polls下的单元测试编写polls/tests.py文件from django.test import TestCaseimport datetimefrom django.utils import timezoneimport timefrom .models import Questionclass QuestionModelTests(TestCase):    def test_was_published_recently_with_future_question(self):        future_time = timezone.now() + datetime.timedelta(days=30)        future_question = Question(pub_date=future_time)        self.assertIs(future_question.was_published_recently(), False)    def test_was_published_recently_with_old_question(self):        old_time = timezone.now() - datetime.timedelta(days=1, seconds=1)        old_question = Question(pub_date=old_time)        self.assertIs(old_question.was_published_recently(), False)    def test_was_published_recently_with_recent_question(self):        recent_time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)        recent_question = Question(pub_date=recent_time)        self.assertIs(recent_question.was_published_recently(), True)然后运行测试python manage.py test polls或者python manage.py test会测试出有一个失败修改polls/models.py中的Questionclass Question(models.Model):    question_text = models.CharField(max_length=200)    pub_date = models.DateTimeField(&apos;date published&apos;)    def __str__(self):        &quot;&quot;&quot;        把question_text的值当做实例转为字符串的结果        :return:        &quot;&quot;&quot;        return &quot;id=%s,question_text=%s, this is __str__&quot; % (self.id, self.question_text)    def was_published_recently(self):        &quot;&quot;&quot;        Question的发布时间是否为1天之内，是则返回True,否则返回False        发布时间若晚于当前时间。也会返回False        :return:        &quot;&quot;&quot;        now = timezone.now()        return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now运行测试，测试通过django测试工具之一 Client的使用clinet可以模拟一个模板渲染环境。让开发者不通过浏览器也可以模拟url的访问先进入项目的shell环境python manage.py shell然后导入setup_test_enviroment&gt;&gt;&gt; from django.test.utils import setup_test_environment&gt;&gt;&gt; setup_test_environment()使用client:&gt;&gt;&gt; from django.test import Client&gt;&gt;&gt; client = Client()# 使用client获取指定地址的返回结果&gt;&gt;&gt; response = client.get(&apos;/&apos;)Not Found: /# 返回结果的http code&gt;&gt;&gt; response.status_code404&gt;&gt;&gt; from django.urls import reverse&gt;&gt;&gt; reverse(&apos;polls:index&apos;)&apos;/polls/&apos;&gt;&gt;&gt; response = client.get(reverse(&apos;polls:index&apos;))&gt;&gt;&gt; response.status_code200# response.content 获取所访问地址的html代码&gt;&gt;&gt; response.content... 此处应显示所访问地址返回的网页html代码。过长故省略显示# response.context可以获取到view传递给模板的数据通过key获取&gt;&gt;&gt; response.context[&apos;lasted_question_list&apos;]&lt;QuerySet [&lt;Question: id=13,question_text=零食买什么？, this is __str__&gt;, &lt;Question: id=2,question_text=今天天气不错！挺风和日丽的！, this is __str__&gt;, &lt;Question: id=12,question_text=不吃饭的时候吃什么？, this is __str__&gt;, &lt;Question: id=11,question_text=今天夜宵吃什么？, this is __str__&gt;, &lt;Question: id=10,question_text=今天晚饭吃什么？, this is __str__&gt;]&gt;调整polls/views.py文件中类IndexView 中的方法get_queryset:class IndexView(generic.ListView):    template_name = &apos;polls/index.html&apos;    context_object_name = &apos;lasted_question_list&apos;    def get_queryset(self):        # pub_date__lte=timezone.now() 是判断pub_date小于等于当前时间        return Question.objects.filter(pub_date__lte=timezone.now()).order_by(&quot;-pub_date&quot;)[:5]然后我们编写测试代码 修改polls/tests.py首先我们创建一个辅助测试的方法def create_question(question_text, days):    publish_time = timezone.now() + datetime.timedelta(days=days)    # 直接使用传入的数据创建数据库的数据,创建成功则返回Question的实例    return Question.objects.create(question_text=question_text,                                   pub_date=publish_time)然后为polls的index页面创建测试方法：class QuestionIndexViewTests(TestCase):    def test_no_questions(self):        response = self.client.get(reverse(&apos;polls:index&apos;))        self.assertEqual(response.status_code, 200)        # 判断返回结果response中是否包含指定的字符串        self.assertContains(response, &apos;没有待投票的问题&apos;)        self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;], [])    def test_past_question(self):        # create_question(&apos;过去发布的question&apos;, -30)        create_question(&apos;past question&apos;, -30)        response = self.client.get(reverse(&apos;polls:index&apos;))        self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;],                                 [&apos;&lt;Question: past question&gt;&apos;])    def test_future_question(self):        # create_question(&apos;未来发布的question&apos;, 30)        create_question(&quot;future question&quot;, 30)        response = self.client.get(reverse(&apos;polls:index&apos;))        self.assertContains(response, &apos;没有待投票的问题&apos;)        self.assertQuerysetEqual(response.context[&quot;lasted_question_list&quot;],                                 [])    def test_future_question_and_past_question(self):        # create_question(&apos;过去发布的question&apos;, -30)        create_question(&apos;past question&apos;, -30)        # create_question(&apos;未来发布的question&apos;, 30)        create_question(&apos;future question&apos;, 30)        response = self.client.get(reverse(&apos;polls:index&apos;))        self.assertQuerysetEqual(response.context[&apos;lasted_question_list&apos;],                                 [&apos;&lt;Question: past question&gt;&apos;])    def test_two_past_question(self):        # create_question(&apos;30天前的数据&apos;, -30)        # create_question(&apos;5天前的数据&apos;, -5)        create_question(&apos;past question 30 days&apos;, -30)        create_question(&apos;past question 5 days&apos;, -5)        response = self.client.get(reverse(&apos;polls:index&apos;))        self.assertQuerysetEqual(            response.context[&apos;lasted_question_list&apos;],            [&apos;&lt;Question: past question 5 days&gt;&apos;, &apos;&lt;Question: past question 30 days&gt;&apos;]        )修改polls的detail页面对应的view解决用户通过url还能够访问未来发布的question的问题： polls/views.pyclass DetailView(generic.DetailView):    model = Question    template_name = &apos;polls/detail.html&apos;    def get_queryset(self):        return Question.objects.filter(pub_date__lte=timezone.now())修改polls/tests.py 编写测试类和测试方法。对detail页面的view进行测试:class QuestionDetailViewTests(TestCase):    &quot;&quot;&quot;    测试点击问题后的详情页面detail相关的view    &quot;&quot;&quot;    def test_future_question(self):        future_question = create_question(question_text=&apos;Future question&apos;, days=5)        url = reverse(&apos;polls:detail&apos;, args=(future_question.id, ))        response = self.client.get(url)        self.assertEqual(response.status_code, 404)    def test_past_question(self):        past_question = create_question(question_text=&apos;Past Question&apos;, days=-5)        url = reverse(&apos;polls:detail&apos;, args=(past_question.id, ))        response = self.client.get(url)        # 断言页面输出结果里包含问题的question_text        self.assertContains(response, past_question.question_text)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第四部分：表单和通用视图</title>
      <link href="/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E8%A1%A8%E5%8D%95%E5%92%8C%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE/"/>
      <url>/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E8%A1%A8%E5%8D%95%E5%92%8C%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<pre><code>表单与通用视图forms表单,即是网页上。由用户操作提交到服务器处理的标签组合修改polls/templates/polls/detail.html&lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;{% if error_message %}<p><strong>{{ error_message }} </strong></p>{% endif %}&lt;form action=&quot;{% url 'polls:vote' question.id %}&quot; method=&quot;post&quot;&gt;    {% csrf_token %}    {% for choice in question.choice_set.all %}        <input type="radio" id="choice{{ forloop.counter }}" value="{{ choice.id }}">        <label for="choice{{ forloop.counter }}"></label>        <br>    {% endfor %}    &lt;input type=&quot;submit&quot; value=&quot;投票&quot; /&gt;&lt;/form&gt;知识点{% csrf_token %} 用于处理跨域请求伪造的危险，在django的模板表单中。都要加上这一行url动态获取，若未在app目录下的urls.py中配置app_name则可使用url path的name属性调用。否则。定义app_name之后就不能单独使用url path的name获取url。必须使用app_name:name的格式，例:    &lt;form action=&quot;{% url 'polls:vote' question.id %}&quot; method=&quot;post&quot;&gt;app_name = &quot;polls&quot;{{ forloop.counter }} 能获取。每次循环的次数。修改 polls/views.py文件的view函数vote:from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom .models import Question, Choicedef vote(request, question_id):    # get_object_or_404 抛出的404不能自定义提示内容。    question = get_object_or_404(Question, pk=question_id)    try:        # request.POST可以获取到所有表单提交的数据        selected_choice = question.choice_set.get(pk=request.POST[&apos;choice&apos;])    except (KeyError, Choice.DoesNotExist):        return render(request, &quot;polls/detail.html&quot;, {            &apos;question&apos;: question,            &apos;error_message&apos;: &quot;您投票的选项不存在或不正确&quot;        })    else:        selected_choice.votes += 1        selected_choice.save()        # HttpResponseRedirect可以跳转到指定地址        # reverse方法可以获取指定url name的地址        return HttpResponseRedirect(reverse(&apos;polls:results&apos;, args=(question.id, )))get_object_or_404方法。可以在获取不到指定条件的数据时。抛出http404异常request.POST可以获取到所有表单中提交的数据。一般以form表单中html标签的name属性作为键名HttpResponseRedirect 可以把页面跳转到指定的urlreverse 可以获取指定path name的url修改polls/views.py文件中的view函数results:from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom .models import Question, Choicedef results(request, question_id):    question = get_object_or_404(Question, pk=question_id)    return render(request, &quot;polls/results.html&quot;, {&apos;question&apos;: question})创建polls/templates/polls/results.html&lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;&lt;ul&gt;    {% for choice in question.choice_set.all %}    <li>{{ choice.choice_text}} -- {{ choice.votes }}</li>    {% endfor %}&lt;/ul&gt;&lt;a href=&quot;{% url 'polls:detail' question.id %}&quot;&gt;我还要再投一次&lt;/a&gt;generic views (可选)通用视图，是对view的优化通用视图(generic views)。一般用于优化使用模板显示的视图(view)本例中用到的通用视图有generice.ListView和generice.DetailView。分别用于向模板传递列表数据和model实例urls.py的匹配顺序。若两个url配置了相同的地址（这往往是失误造成的）,那么仅有先定义的地址会被匹配到。未被匹配到的定义会被忽略，但仍能被path name读取到。修改polls/views.py:from django.shortcuts import render, get_object_or_404from django.http import HttpResponse, Http404, HttpResponseRedirectfrom django.urls import reversefrom .models import Question, Choicefrom django.views import genericclass IndexView(generic.ListView):    template_name = &apos;polls/index.html&apos;    context_object_name = &apos;latest_question_list&apos;    def get_queryset(self):        return Question.objects.order_by(&quot;-pub_date&quot;)[:5]class DetailView(generic.DetailView):    model = Question    template_name = &apos;polls/detail.html&apos;class ResultsView(generic.DetailView):    model = Question    template_name = &apos;polls/results.html&apos;修改polls/urls.pyfrom django.urls import path, re_pathfrom . import views# 定义app_name可用于动态调用url path的name,# 但是定义之后就不能单独使用url path的name获取urlapp_name = &quot;polls&quot;urlpatterns = [    path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;),    path(&apos;&lt;int:pk&gt;&apos;, views.DetailView.as_view(), name=&apos;detail&apos;),    path(&apos;&lt;int:pk&gt;/results/&apos;, views.ResultsView.as_view(), name=&apos;results&apos;),    # 例: /polls/5/vote/    path(&quot;&lt;int:question_id&gt;/vote/&quot;, views.vote, name=&apos;vote&apos;),]注意。detail和result这两个url的配置。原本为qustion_id的地方改为了pk.这会让参数匹配通用视图中指定的model把通用视图定义的类用作path的指定view需要调用as_view()方法使用查询表达式 F 解决数据提交的竞争问题&gt;&gt;&gt; from django.db.models import F&gt;&gt;&gt; c1 = Choice.objects.get(pk=1)&gt;&gt;&gt; c2 = Choice.objects.get(pk=1)&gt;&gt;&gt; c1.votes1&gt;&gt;&gt; c2.votes1&gt;&gt;&gt; c1.votes = F(&apos;votes&apos;) + 1&gt;&gt;&gt; c2.votes = F(&apos;votes&apos;) + 1&gt;&gt;&gt; c1.save()&gt;&gt;&gt; c2.save()django的request对象和response对象 参考链接： https://docs.djangoproject.com/en/2.1/ref/request-response/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第三部分：视图和模板</title>
      <link href="/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E8%A7%86%E5%9B%BE%E5%92%8C%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/12/10/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E8%A7%86%E5%9B%BE%E5%92%8C%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<pre><code>url的配置关于结尾的斜杠/, 若配置的结尾加上斜杠,则url的结尾无论是否有斜杠均可访问；若配置的结尾没有斜杠。则 url的结尾不能是斜杠# 如下面这一条。使用  /polls/5/ 或者 /polls/5 都可访问path(&quot;&lt;int:question_id&gt;/&quot;, views.Detail, name=&apos;detail&apos;),# 而下面这一条。使用 /polls/5 可以访问 ,使用/polls/5/不可访问path(&quot;&lt;int:question_id&gt;&quot;, views.Detail, name=&apos;detail&apos;),view的参数要与urls.py中配置的参数名一致。区分大小写使用模板(template)与view结合显示数据第一步，在views.py所在的目录中建立templates文件夹第二步，在settins.py文件中的TEMPLATES常量中进行配置。把第一步的文件夹路径配置到TEMPLATES中的DIRS中。把APP_DIRS设为TrueTEMPLATES = [    {        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,        &apos;DIRS&apos;: [            os.path.join(BASE_DIR, &quot;polls/templates&quot;),        ],        &apos;APP_DIRS&apos;: True,        &apos;OPTIONS&apos;: {            &apos;context_processors&apos;: [                &apos;django.template.context_processors.debug&apos;,                &apos;django.template.context_processors.request&apos;,                &apos;django.contrib.auth.context_processors.auth&apos;,                &apos;django.contrib.messages.context_processors.messages&apos;,            ],        },    },]第三步，在templates目录下创建polls目录。并在此目录下创建index.html文件，最终的相对路径是 /polls/templates/polls/index.html{% if lasted_question_list %}    <ul>        {% for question in lasted_question_list %}        <li><a href="/polls/{{question.id}}/">{{ question.question_text }}</a></li>        {% endfor %}    </ul>{% else %}    <p>没有待投票的问题</p>{% endif %}修改对应的view, polls/views.py# 不推荐的做法是。在view中。把数据显示方式硬编码def Index(request):    # polls的默认页面。会显示待投票的问题的列表.    lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5]    output = &apos;,&apos;.join([q.question_text for q in lastest_question_list])    return HttpResponse(output)推荐做法1：# 较为复杂的使用模板文件的方式def Index(request):    # polls的默认页面。会显示待投票的问题的列表.    lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5]    template = loader.get_template(&quot;polls/index.html&quot;)    context = {         &quot;lasted_question_list&quot;: lastest_question_list    }    return HttpResponse(template.render(context, request))推荐做法2：# 较为简单的使用模板文件的方式def Index(request):    # polls的默认页面。会显示待投票的问题的列表.    lastest_question_list = Question.objects.order_by(&quot;-pub_date&quot;)[:5]    context = {        &quot;lasted_question_list&quot;: lastest_question_list    }    return render(request, &quot;polls/index.html&quot;, context)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Diango入门项目-第二部分:模型和管理站点</title>
      <link href="/2018/12/10/Diango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%AE%A1%E7%90%86%E7%AB%99%E7%82%B9/"/>
      <url>/2018/12/10/Diango%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%AE%A1%E7%90%86%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre><code>数据库的配置settings.py 配置DATABASES常量DATABASES = {    &apos;default&apos;: {        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,        &apos;NAME&apos;: &apos;mysite&apos;,        &apos;HOST&apos;: &apos;127.0.0.1&apos;,        &apos;PORT&apos;: 3306,        &quot;PASSWORD&quot;: &apos;123456&apos;,        &apos;USER&apos;: &apos;root&apos;    }}django项目的数据库定义同步到数据库若是配置使用mysql。执行此命令前需要在主目录的文件夹下的__init__.py文件中加入下面两行代码：import pymysqlpymysql.install_as_MySQLdb()例如创建了mysite项目。则项目目录名为mysite。内部的主目录为mysite.文件的路径则为 mysite/mysite/__init__.py初次创建项目后可使用以下命令python manage.py migrate修改models.py文件后若要把models同步到数据库先把settings.py中的INSTALLED_APPS 加上修改的app   例如把新创建的app名称为 polls加入：  &apos;polls.apps.PollsConfig&apos;然后执行：python manage.py makemigrations执行成功后再执行: python manage.py migrate执行成功。则models.py中的数据库定义会同步到数据库创建成功会多出两个表django shell 环境的使用进入项目文件夹执行命令：python manage.py shell数据查询语法：  django 的 orm语法   查询model对应的数据库表的数据        所有数据： Question.objects.all()               此命令返回的是QuerySet类型。并不会随数据库数据实时更新                QuerySet相当于model类的实例的列表。每个实例相当于对应数据库表中的一条数据        按条件查询： Question.objects.filter               例如按照Question的id查询,查询id=1的数据：                       Question.objects.filter(id=1)                返回结果的类型是QuerySet。与objects.all()用法一致         查询指定条件的model实例.使用objects.get.例如：               q = Question.objects.get(id=1)                print(q.id)                * 注意：若指定的条件不存在对应的数据。则将报错                              若指定的条件存在对应的多条数据。也会报错。          模糊查询：                    q_list = Question.objects.filter(question_text__startswith=&apos;今天&apos;)                    将查出question_text的文字中使用今天这两个字开头的所有数据           查询结果的排序：                    不指定排序字段的时候。一般会自动使用id  正序排序( ASC)                    指定排序字段。默认为正序排序                            Question.objects.all().order_by(&quot;pub_date&quot;)                     在指定排序字段前加上-号。会按此字段倒序排列（DESC）                         Question.objects.all().order_by(&quot;-pub_date&quot;)]                         利用外键查询：                        使用model中定义的ForeignKey 可以访问到对应的外键表数据                        例如：                                question_1 = Question.objects.get(id=1)   # 取出question表id=1的数据                                choice_1 = Choice.objects.get(id=1)    #取出choice表id=1的数据                                 # Choice的question为ForeighKey类型的属性。并且指向了Question则：                                 choice_1.question 与 question_1的类型是相同的                           通过外键指定查询条件                                 Choice.objects.filter(question__pub_date__year=2018)                             上面的语句会查询出。choice表中对应的question  pub_date字段year=2018的所有      数据   新增数据：        创建对应model的实例，例如                   frmo django.utils import timezone                   q = Question(question_text=&apos;今天是星期几?&apos;, pub_date=timezone.now())                    q.save()        执行q.save()之后。数据会写入到数据库对应的表中更新数据：       需要先获取到对应数据库数据相对的model的实例，例如                   q = Question.objects.all()                    q1 = q[0]                    q1.question_text = &quot;xxxx&quot;                     q1.save()          执行save之后。数据库的数据会被更改删除数据：      可使用QuerySet调用 delete() 会删除查询到的所有数据,例如：                 删除所有数据:    Question.objects.all().delete()                 删除指定条件的数据： Question.objects.filter(id=5).delete()      也可以使用models的实例调用delete。 会删除数据库对应的那条数据.例如：                q  = Question.objects.filter(id=5)                 q[0].delete()                此时q[0]为Question的实例Admin      django默认设置的后台管理界面。登录地址默认为  http://127.0.0.1:8000/admin       需要添加管理员账号才可访问：       添加管理员账号的命令是：               进入项目根目录。也就是manage.py 所在的同一级目录                执行命令：python manage.py createsuperuser    会进入用户名。邮箱。密码的输入界面 。全部输入完毕后会提示    Superuser created successfully.   这时候输入的用户名就可以用来登录admin后台        把自定义的app中的model加入到后台进行管理：              1.定义model               2.在app目录下的admin.py文件中。导入要加入到后台管理的model 。然后添加注册语句，例如：                          from django.contrib import admin                          from .models import Question                           admin.site.register(Question)                            修改保存后。再次打开后台。登录成功即可管理Question对应的数据库表</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>月亮惹的祸</title>
      <link href="/2018/11/30/%E9%83%BD%E6%98%AF%E6%9C%88%E4%BA%AE%E6%83%B9%E7%9A%84%E7%A5%B8/"/>
      <url>/2018/11/30/%E9%83%BD%E6%98%AF%E6%9C%88%E4%BA%AE%E6%83%B9%E7%9A%84%E7%A5%B8/</url>
      
        <content type="html"><![CDATA[<pre><code>《月亮惹的祸》是因为张宇与妻子十一郎突发奇想，决定在加拿大闪婚。  但是事后两人面对媒体对于闪婚理由的追问，却讲不出原因，正好张宇想起结婚那天的月亮特别圆， 于是十一郎亲自写了这首词，把所有两人闪婚的原因都归结给了月亮，“就当是月亮惹的祸吧”。  两人表示歌曲就是他们爱的产物，而该曲的创作则是在两人结婚后完成的。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 一首歌一个故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一首歌一个故事 </tag>
            
            <tag> 张宇 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Walk Away</title>
      <link href="/2018/11/25/walk%20away/"/>
      <url>/2018/11/25/walk%20away/</url>
      
        <content type="html"><![CDATA[<pre><code>《Walk Away》是歌手Dia Frampton第一张个人专辑《RED》里的一首歌。   发行时间是2011-12-06，音乐时长是4:14。创作背景“WalkAway”的背景是作者根据真实故事写的，一个合适的年纪只有八岁的小女孩,  被父亲&quot;送给&quot;那些狗友任其娱乐。故事的结局是小女孩并没有做出任何报复。  作者认为很不值，就写这首歌，歌曲里，小女孩回来报复那些混蛋。</code></pre><a id="more"></a><pre><code>歌曲歌词    Looking back on younger days, the time has passed,    回顾年少时候的那段时光，一切都已过去    And nothing stays the same. Hey hey hey!    一切都已改变。嘿 嘿 嘿    She was such a pretty girl,    她是如此美的小女孩    With glowing eyes and yellow curls. Hey hey hey!    她有着闪闪发亮的眼睛和一头金黄色的卷发 嘿 嘿 嘿    Stars are in a summer night,    在那星空下的夏夜    She&apos;s wishing that they&apos;d fall down through the atmosphere,    她希望那些人能够下地狱    For a souvenir.    以此来祭奠（她所受的伤害）    She&apos;s waiting for her Superman, her Never land,    她等待她的超人能够来临，带她去永无之乡    Cause he can show the way. Hey hey hey!    他知道该如何去那里。嘿 嘿 嘿    Where&apos;s her missing piece her mind&apos;s been chasing, chasing?    那已迷失的，她内心一直所追寻的地方在哪里    A bullet with your name, a ticking time grenade,    一粒已瞄准的子弹，一颗定时炸弹    You better run away, run away, run away    你们无处可逃 无处可逃 无处可逃    Either way you&apos;re screwed, there&apos;s nothing you can do,    你们所有的挣扎都是徒劳    You better run away, run away, run away.    你们无处可逃 无处可逃 无处可逃    She&apos;s tellin&apos; tales through telephone    她透过电话告诉你们一切    That make you cry, chill to the bone. Hey hey hey!    这使你们害怕到哭泣，那恐惧渗入骨髓 嘿 嘿 嘿    It&apos;s lock and key, electrified,    一切都在掌控之中    Hide and seek from dirty eyes. Hey hey hey!    你们那那肮脏的眼睛里还想躲藏些什么 嘿 嘿 嘿    Driving in the rain to somewhere far,    冒着大雨想开车离去，远离这里    But they&apos;ve got tattoos stamped upon their arms, of her name in hearts    但他们却不知自己的双手却早已满是罪证 对她的名字刻骨铭心    She doesn&apos;t understand that love is what you give, not given up.    她无法理解爱是被给予 而不是被放弃    Hey hey hey!    嘿 嘿 嘿    Where&apos;s her missing piece her mind&apos;s been chasing, chasing?    那已迷失的，她内心一直所追寻的地方在哪里    A bullet with your name, a ticking time grenade,    一粒已瞄准的子弹，一颗定时炸弹    You better run away, run away, run Away    你们无处可逃 无处可逃 无处可逃    Either way you&apos;re screwed, there&apos;s nothing you can do,    你们所有的挣扎都是徒劳    No matter what you say, what you say, what you say.    说什么都于事无补 于事无补 于事无补    Yeah you better not sleep, because she&apos;s waiting, waiting.    你最好不要就这么睡去，她像等待猎人等待猎物般在等待着你    She knows all about you; you&apos;re in her aim.    她知道你们的一切 你们是她的目标    A bullet with your name, a ticking time grenade,    一粒已瞄准的子弹，一颗定时炸弹    You better run away, run away, run away    你们无处可逃 无处可逃 无处可逃    Either way you&apos;re screwed, there&apos;s nothing you can do,    你们所有的挣扎都是徒劳    You better run away, run away, run away    你们无处可逃 无处可逃 无处可逃    A bullet with your name, a ticking time grenade,    一粒已瞄准的子弹，一颗定时炸弹    You better run away, run away, run away    你们无处可逃 无处可逃 无处可逃    Either way you&apos;re screwed, there&apos;s nothing you can do,    你们所有的挣扎都是徒劳    No matter what you say, what you say, what you say.        说什么都于事无补 于事无补 于事无补  评论分享有人说这首《Walk Away》好听，只是感觉音乐风格跟故事不符合”。我并不这么认为。  在我看来，所有的悲剧不一定要需要控诉和呐喊来表达，  它完全可以是一种极其自我风格化的呈现。就像The Cranberries表达反战的《Zombie》，也没有用太沉痛的音色去演绎。  而《Walk Away》就是想用快节奏来盛放一个悲剧，歌手想象女孩在被性侵之后化身持有猎枪的强者，  用子弹瞄准所有伤害她的人。现实里难以打击的愤怒，  便在作品里以艺术形式来义愤填膺。这是平淡世界里难得的英雄主义。复仇者，世界总是有些看，上去软弱好欺的人在不断忍受着别人无底限的踩压，  不知道反抗却用最友善最有力的另外一种方式表达着内心的愤怒与不满，  一如这歌里的小女孩，遭遇性侵却转化成歌来表达自己的心情。    像这小女孩，要走出来，有保护自己的能力，无底限的善良只会是纵容了别人的坏。善良过度是懦弱。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 一首歌一个故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一首歌一个故事 </tag>
            
            <tag> Dia Frampton </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django入门项目-第一部分：请求与响应</title>
      <link href="/2018/10/31/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
      <url>/2018/10/31/Django%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<pre><code>终端执行：py -m django --version(查看Django版本)一、创建一个文件夹管理django项目文件二、创建项目 Django-admin startproject mysite(项目名称)三、启动项目的web服务器。在项目的根目录中执行: py manage.py runserver(默认端口为8000，默认访问ip为本地。本地ip一般为127.0.0.1或者localhost  可以指定端口 py manage.py runserver 8000(端口号/0：端口号)四、创建一个app py manage.py startapp polls五、打开文件polls/views.py 并在加入以下Python代码：    from django.http import HttpResponse    def index(request):        return HttpResponse(&quot;Hello, Word.&quot;)六、在polls/views.py 文件中加入以下代码：        from django.http import HttpResponse        def index(request):            return HttpResponse(&quot;Hello, world.&quot;)七、在mysite/urls.py 文件中输入：        from django.contrib import admin        from django.urls import path, include        urlpatterns = [            path(&apos;polls/&apos;, include(&apos;polls.urls&apos;))            path(&apos;admin/&apos;,admin.site.urls)        ]八、在项目根目录中执行： py manage.py runserver(在浏览器中执行http://127.0.0.1:8000/polls/ (在Starting development server显示的http地址，这里我执行显示的是http://127.0.0.1:8000/polls ))，一切正常的话你将看到“Hello, world”</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑白五子棋-self版</title>
      <link href="/2018/10/27/wuziqi/"/>
      <url>/2018/10/27/wuziqi/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html><head>    <meta charset="utf-8">    <title>五子棋</title>    <!-- <link rel="stylesheet" type="text/css" href="css/style.css"> -->    <style>    canvas{display: block;margin: 50px auto;box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9;}.restart{text-align: center;}.restart>span{display: inline-block;padding: 10px 20px;color: #fff;background-color: #C92027;border-radius: 5px;}    </style></head><body>    <div>        <h3>黑白五子棋-self版</h3>    </div>    <canvas id="chess" width="450px" height="450px"></canvas>    <div id="restart" class="restart">            <span>重新开始</span>        </div></body></html><script>//判断是否结束var over = false;//判断落子方var me = true; //我var chressBord = [];//棋盘for(var i = 0; i < 15; i++){    chressBord[i] = [];    for(var j = 0; j < 15; j++){        chressBord[i][j] = 0;    }}//赢法的统计数组var myWin = [];var computerWin = [];//赢法数组var wins = [];for(var i = 0; i < 15; i++){    wins[i] = [];    for(var j = 0; j < 15; j++){        wins[i][j] = [];    }}var count = 0; //赢法总数//横线赢法for(var i = 0; i < 15; i++){    for(var j = 0; j < 11; j++){        for(var k = 0; k < 5; k++){            wins[i][j+k][count] = true;        }        count++;    }}//竖线赢法for(var i = 0; i < 15; i++){    for(var j = 0; j < 11; j++){        for(var k = 0; k < 5; k++){            wins[j+k][i][count] = true;        }        count++;    }}//正斜线赢法for(var i = 0; i < 11; i++){    for(var j = 0; j < 11; j++){        for(var k = 0; k < 5; k++){            wins[i+k][j+k][count] = true;        }        count++;    }}//反斜线赢法for(var i = 0; i < 11; i++){    for(var j = 14; j > 3; j--){        for(var k = 0; k < 5; k++){            wins[i+k][j-k][count] = true;        }        count++;    }}for(var i = 0; i < count; i++){    myWin[i] = 0;    computerWin[i] = 0;}//获得canvas对象var chess = document.getElementById("chess");var context = chess.getContext('2d');context.strokeStyle = '#bfbfbf'; //边框颜色var logo = new Image();logo.src = 'https://ss3.baidu.com/-rVXeDTa2gU2pMbgoY3K/it/u=3854101686,5663584&fm=202&src=766&mola=new&crop=v1';logo.onload  = function(){    context.drawImage(logo,0,0,450,450);    drawChessBoard();}document.getElementById("restart").onclick = function(){    window.location.reload();}chess.onclick = function(e){    if(over){        return;    }    if(!me){        return;    }    var x = e.offsetX;    var y = e.offsetY;    var i = Math.floor(x / 30);    var j = Math.floor(y / 30);    if(chressBord[i][j] == 0){        oneStep(i,j,me);        chressBord[i][j] = 1;//我                for(var k = 0; k < count; k++){            if(wins[i][j][k]){                myWin[k]++;                computerWin[k] = 6;//这个位置对方不可能赢了                if(myWin[k] == 5){                    window.alert('你赢了');                    over = true;                }            }        }        if(!over){            me = !me;            computerAI();        }    }}//计算机下棋var computerAI = function (){    var myScore = [];    var computerScore = [];    var max = 0;    var u = 0, v = 0;    for(var i = 0; i < 15; i++){        myScore[i] = [];        computerScore[i] = [];        for(var j = 0; j < 15; j++){            myScore[i][j] = 0;            computerScore[i][j] = 0;        }    }    for(var i = 0; i < 15; i++){        for(var j = 0; j < 15; j++){            if(chressBord[i][j] == 0){                for(var k = 0; k < count; k++){                    if(wins[i][j][k]){                        if(myWin[k] == 1){                            myScore[i][j] += 200;                        }else if(myWin[k] == 2){                            myScore[i][j] += 400;                        }else if(myWin[k] == 3){                            myScore[i][j] += 2000;                        }else if(myWin[k] == 4){                            myScore[i][j] += 10000;                        }                        if(computerWin[k] == 1){                            computerScore[i][j] += 220;                        }else if(computerWin[k] == 2){                            computerScore[i][j] += 420;                        }else if(computerWin[k] == 3){                            computerScore[i][j] += 2100;                        }else if(computerWin[k] == 4){                            computerScore[i][j] += 20000;                        }                                            }                }                if(myScore[i][j] > max){                    max  = myScore[i][j];                    u = i;                    v = j;                }else if(myScore[i][j] == max){                    if(computerScore[i][j] > computerScore[u][v]){                        u = i;                        v = j;                        }                }                if(computerScore[i][j] > max){                    max  = computerScore[i][j];                    u = i;                    v = j;                }else if(computerScore[i][j] == max){                    if(myScore[i][j] > myScore[u][v]){                        u = i;                        v = j;                        }                }            }        }    }    oneStep(u,v,false);    chressBord[u][v] = 2;    for(var k = 0; k < count; k++){        if(wins[u][v][k]){            computerWin[k]++;            myWin[k] = 6;//这个位置对方不可能赢了            if(computerWin[k] == 5){                window.alert('艾小博赢了');                over = true;            }        }    }    if(!over){        me = !me;    }}//绘画棋盘var drawChessBoard = function(){    for(var i = 0; i < 15; i++){        context.moveTo(15 + i * 30 , 15);        context.lineTo(15 + i * 30 , 435);        context.stroke();        context.moveTo(15 , 15 + i * 30);        context.lineTo(435 , 15 + i * 30);        context.stroke();    }}//画旗子var oneStep = function(i,j,me){    context.beginPath();    context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI);//画圆    context.closePath();    //渐变    var gradient = context.createRadialGradient(15 + i * 30 + 2, 15 + j * 30 - 2, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0);    if(me){        gradient.addColorStop(0,'#0a0a0a');        gradient.addColorStop(1,'#636766');    }else{        gradient.addColorStop(0,'#d1d1d1');        gradient.addColorStop(1,'#f9f9f9');    }    context.fillStyle = gradient;    context.fill();}</script>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> Javascript </tag>
            
            <tag> 五子棋 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>时钟</title>
      <link href="/2018/10/26/clock/"/>
      <url>/2018/10/26/clock/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html><head><title>时钟</title><meta charset="utf-8"><style type="text/css">body{background-color: lightblue;}.box{width: 400px;height: 400px;border-radius: 50%;background-image: linear-gradient(to right bottom,red,orange,yellow,green,blue,purple);/*阴影inset  ： 内阴影第一个值：影子水平方向的偏移量第二个值：影子垂直方向的偏移量第三个值：阴影模糊度第四个值：阴影半径第五个值：阴影颜色*//*box-shadow:  8px 10px 5px 10px ;*/margin: 200px auto;position: relative;background-image: url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1936864453,146348825&fm=200&gp=0.jpg);background-size: 100% 100%;}#clock{width: 350px;height: 350px;background-color: white;border-radius: 50%;position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto;background-size: 100% 100%;}.dot{width: 3px;height: 350px;/*background-color: blue;*/position: absolute;left: 171px;/*animation: xz 60s infinite linear;*/background-image: linear-gradient(to bottom,black ,black 10px,transparent 10px ,transparent 340px,black 340px,black);}.dot:nth-child(5n+1){width: 6px;background-image: linear-gradient(to bottom,black ,black 17px,transparent 17px ,transparent 333px,black 333px,black);left: 171px;}@keyframes xz{0%{transform: rotate(0deg);}100%{transform: rotate(360deg);}}.num{width: 20px;height: 158px;/*background-color: yellow;*/position: absolute;left: 165px;bottom: 175px;transform-origin: center bottom;}.num>div{text-align: center;/*background-color: red;*/line-height: 20px;}#hour{width: 10px;height: 70px;background-color: rgba(0,0,255,0.5);position: absolute;bottom: 200px;left: 195px;transform-origin: center bottom;border-radius: 5px;}#minute{width: 6px;height: 90px;background-color: rgba(0,255,255,0.5);position: absolute;bottom: 200px;left: 197px;transform-origin: center bottom;border-radius: 3px;}#second{width: 4px;height: 110px;background-color: rgba(255,0,0,0.5);position: absolute;bottom: 200px;left: 198px;transform-origin: center bottom;border-radius: 50%;}#qiu{width: 20px;height: 20px;border-radius: 10px;background-color: black;position: absolute;top: 0;bottom: 0;left: 0;right: 0;margin: auto;}</style></head><body><h3>时钟</h3><div class="box"><div id="clock"></div><div id="hour"></div><div id="minute"></div><div id="second"></div><div id="qiu"></div></div></body></html><script type="text/javascript">var clockDiv = document.getElementById("clock");for (var i = 0; i < 30; i++) {// 创建元素var div = document.createElement("div");// 给元素添加类名div.className = "dot";var s = " rotate(" + i * 6 +"deg)";// if (i % 5 ==0) {// div.style.width = "6px";// }div.style.transform = s;clockDiv.appendChild(div);}// 添加数字for (var i = 1; i <= 12; i++) {// 创建 class 为 num 的 divvar numDiv = document.createElement("div");numDiv.className = "num";var inDiv = document.createElement("div");// 给 inDiv 添加内容 inDiv.innerHTML = i;// numDiv.style.transform.origin = "50% calc(" + 50% + 158 + "px)";numDiv.style.transform = "rotate(" + i * 30 +"deg)";inDiv.style.transform = "rotate(" + i *  -30 +"deg)";numDiv.appendChild(inDiv);clockDiv.appendChild(numDiv);}// 获取时针、分针、秒针var hourDiv = document.getElementById("hour");var minuteDiv = document.getElementById("minute");var secondDiv = document.getElementById("second");function click(){// 获取时间对象var date = new Date();// 获取时、分、秒var h = date.getHours();var m = date.getMinutes();var s = date.getSeconds();// 秒针旋转的角度secondDiv.style.transform = "rotate(" + s * 6 +"deg)";minuteDiv.style.transform = "rotate(" + (m * 6 + s * 6 / 60) +"deg)";hourDiv.style.transform = "rotate(" + (h * 30 + m * 0.5) +"deg)";}click();// 定时器setInterval(click,500);</script>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> 时钟 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
